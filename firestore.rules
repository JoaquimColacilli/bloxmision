rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // FUNCIONES HELPER
    // ============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             request.auth.token.email == 'admin@bloxmision.com';
    }
    
    function isValidPlayerLevel(level) {
      return level in ['Grumete', 'Marinero', 'Navegante', 'Timonel', 'Contramaestre', 'Piloto', 'Primer Oficial', 'Capitán', 'Almirante', 'Leyenda Pirata'];
    }

    // Count keys in a map (Firestore security rules helper)
    function mapSize(m) {
      return m.keys().size();
    }
    
    // ============================================
    // USERS COLLECTION
    // Solo el dueño puede leer/escribir su documento
    // XP solo puede aumentar (anti-cheating)
    // Fragment system validation included
    // ============================================
    
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      
      // CREATE: Solo documento propio con datos iniciales válidos
      allow create: if isOwner(userId)
        && request.resource.data.uid == userId
        && request.resource.data.totalXP == 0
        && request.resource.data.currentWorld == 1
        && request.resource.data.currentLevel == 1
        && request.resource.data.playerLevel == 'Grumete'
        // Fragment system: must start empty
        && request.resource.data.unlockedFragmentsMap == {}
        && request.resource.data.treasureFragmentsCount == 0
        && request.resource.data.mapCompleted == false;
      
      // UPDATE: Documento propio con límites razonables
      // Core security: uid cannot change, XP can only increase (or be recalculated)
      allow update: if isOwner(userId)
        // UID must remain unchanged (only validate if uid field is being touched)
        && (
          !('uid' in request.resource.data.diff(resource.data).affectedKeys())
          || request.resource.data.uid == resource.data.uid
        )
        // XP validation: must be >= 0 and <= 100000
        && request.resource.data.totalXP >= 0
        && request.resource.data.totalXP <= 100000
        // Fragment map validation - simplified to just exist check if present
        && (
          !('unlockedFragmentsMap' in request.resource.data.diff(resource.data).affectedKeys())
          || request.resource.data.unlockedFragmentsMap is map
        )
        // Fragment count simple check
        && (
          !('treasureFragmentsCount' in request.resource.data.diff(resource.data).affectedKeys())
          || request.resource.data.treasureFragmentsCount is number
        );
      
      // DELETE: Nunca permitido desde cliente
      allow delete: if false;
      
      // ============================================
      // USER PROGRESS SUBCOLLECTION
      // Deterministic docId: /users/{uid}/progress/{levelId}
      // Inmutable: solo CREATE, no UPDATE/DELETE
      // Must be written in same transaction as user update
      // ============================================
      
      match /progress/{levelId} {
        // READ: Solo registros propios
        allow read: if isOwner(userId);
        
        // CREATE: Validar campos requeridos y límites
        // Uses getAfter to validate user doc is being updated in same transaction
        allow create: if isOwner(userId)
          && request.resource.data.levelId == levelId
          && request.resource.data.completed == true
          && request.resource.data.attempts >= 1 && request.resource.data.attempts <= 1000
          && request.resource.data.usedHints >= 0
          && request.resource.data.xpEarned >= 0 && request.resource.data.xpEarned <= 300
          && request.resource.data.stars >= 1 && request.resource.data.stars <= 3
          && request.resource.data.blockCount >= 1 && request.resource.data.blockCount <= 100
          && request.resource.data.worldId is string
          // Atomicity validation: user doc must be updated in same transaction
          && (
            getAfter(/databases/$(database)/documents/users/$(userId)).data.totalXP 
            >= get(/databases/$(database)/documents/users/$(userId)).data.totalXP
          );
        
        // INMUTABLE: No updates ni deletes
        allow update, delete: if false;
      }
      
      // ============================================
      // USER INVENTORY SUBCOLLECTION (JorCoins Shop)
      // /users/{uid}/inventory/{itemId}
      // Immutable purchases - create only in transaction
      // ============================================
      
      match /inventory/{itemId} {
        // READ: Only own inventory
        allow read: if isOwner(userId);
        
        // CREATE: Valid purchase in transaction
        // Must be accompanied by jorCoins decrease
        allow create: if isOwner(userId)
          && request.resource.data.itemId == itemId
          && request.resource.data.pricePaid >= 0
          // Verify jorCoins decreased in same transaction
          && (
            getAfter(/databases/$(database)/documents/users/$(userId)).data.jorCoins
            <= get(/databases/$(database)/documents/users/$(userId)).data.jorCoins
          );
        
        // IMMUTABLE: No updates or deletes
        allow update, delete: if false;
      }
      
      // ============================================
      // USER TRANSACTIONS SUBCOLLECTION (JorCoins History)
      // /users/{uid}/transactions/{txId}
      // Immutable transaction log
      // ============================================
      
      match /transactions/{txId} {
        // READ: Only own transactions
        allow read: if isOwner(userId);
        
        // CREATE: Valid transaction record
        allow create: if isOwner(userId)
          && request.resource.data.type in ['purchase', 'reward']
          && request.resource.data.price is number;
        
        // IMMUTABLE: No updates or deletes
        allow update, delete: if false;
      }
    }
    
    // ============================================
    // LEGACY PROGRESS COLLECTION (for migration)
    // Read-only for backwards compatibility
    // ============================================
    
    match /progress/{progressId} {
      // READ: Solo registros propios
      allow read: if isAuthenticated() 
        && resource.data.userId == request.auth.uid;
      
      // No new writes allowed - use subcollection instead
      allow create, update, delete: if false;
    }
    
    // ============================================
    // LEVELS COLLECTION
    // Solo lectura para usuarios autenticados
    // ============================================
    
    match /levels/{levelId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // WORLDS COLLECTION
    // Solo lectura para jugadores
    // ============================================
    
    match /worlds/{worldId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // MAP FRAGMENTS COLLECTION
    // Solo lectura
    // ============================================
    
    match /mapFragments/{fragmentId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // BADGES COLLECTION (catálogo)
    // Solo lectura
    // ============================================
    
    match /badges/{badgeId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // LEADERBOARD COLLECTION
    // Lectura pública, escritura solo server/admin
    // ============================================
    
    match /leaderboard/{entry} {
      allow read: if true;
      allow write: if false;
    }
  }
}
