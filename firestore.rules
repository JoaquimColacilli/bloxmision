rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // FUNCIONES HELPER
    // ============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             request.auth.token.email == 'admin@bloxmision.com';
    }
    
    function isValidPlayerLevel(level) {
      return level in ['Grumete', 'Marinero', 'Navegante', 'Timonel', 'Contramaestre', 'Piloto', 'Primer Oficial', 'Capitán', 'Almirante', 'Leyenda Pirata'];
    }

    // Count keys in a map (Firestore security rules helper)
    function mapSize(m) {
      return m.keys().size();
    }
    
    // ============================================
    // USERS COLLECTION
    // Solo el dueño puede leer/escribir su documento
    // XP solo puede aumentar (anti-cheating)
    // Fragment system validation included
    // ============================================
    
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      
      // CREATE: Solo documento propio con datos iniciales válidos
      allow create: if isOwner(userId)
        && request.resource.data.uid == userId
        && request.resource.data.totalXP == 0
        && request.resource.data.currentWorld == 1
        && request.resource.data.currentLevel == 1
        && request.resource.data.playerLevel == 'Grumete'
        // Fragment system: must start empty
        && request.resource.data.unlockedFragmentsMap == {}
        && request.resource.data.treasureFragmentsCount == 0
        && request.resource.data.mapCompleted == false;
      
      // UPDATE: Documento propio con límites razonables
      // Core security: uid cannot change, XP can only increase (or be recalculated)
      // Fragment rules: map can only grow, count must match map size, mapCompleted only when 15
      allow update: if isOwner(userId)
        && request.resource.data.uid == resource.data.uid  // UID inmutable
        && (
          // Rule 1: XP increases (normal gameplay)
          request.resource.data.totalXP >= resource.data.totalXP
          // Rule 2: OR XP is being set to any value >= 0 (for recalculation from progress)
          || request.resource.data.totalXP >= 0
        )
        && request.resource.data.totalXP <= 100000  // Max cap
        && (
          // If playerLevel is being updated, validate it
          !('playerLevel' in request.resource.data.diff(resource.data).affectedKeys())
          || isValidPlayerLevel(request.resource.data.playerLevel)
        )
        // Fragment system validation
        && (
          // If fragments not being updated, skip validation
          !('unlockedFragmentsMap' in request.resource.data.diff(resource.data).affectedKeys())
          || (
            // Validate only if the field exists in the current document
            // Legacy users might not have this field
            !('unlockedFragmentsMap' in resource.data)
            || (
              // Fragments map can only GROW (new keys must include all old keys)
              request.resource.data.unlockedFragmentsMap.keys().hasAll(
                resource.data.unlockedFragmentsMap.keys()
              )
              // Max 15 fragments
              && mapSize(request.resource.data.unlockedFragmentsMap) <= 15
            )
          )
        )
        && (
          // treasureFragmentsCount validation
          !('treasureFragmentsCount' in request.resource.data.diff(resource.data).affectedKeys())
          || (
            // If unlockedFragmentsMap doesn't exist yet, count must be 0 or match new map
            !('unlockedFragmentsMap' in request.resource.data)
            || request.resource.data.treasureFragmentsCount == mapSize(request.resource.data.unlockedFragmentsMap)
          )
        )
        && (
          // mapCompleted can only go false->true when count == 15
          !('mapCompleted' in request.resource.data.diff(resource.data).affectedKeys())
          || (
            // Was false, now true, and count is 15
            (resource.data.mapCompleted == false 
             && request.resource.data.mapCompleted == true 
             && request.resource.data.treasureFragmentsCount == 15)
            // Or staying the same
            || request.resource.data.mapCompleted == resource.data.mapCompleted
            // Or legacy: mapCompleted doesn't exist yet
            || !('mapCompleted' in resource.data)
          )
        );
      
      // DELETE: Nunca permitido desde cliente
      allow delete: if false;
      
      // ============================================
      // USER PROGRESS SUBCOLLECTION
      // Deterministic docId: /users/{uid}/progress/{levelId}
      // Inmutable: solo CREATE, no UPDATE/DELETE
      // Must be written in same transaction as user update
      // ============================================
      
      match /progress/{levelId} {
        // READ: Solo registros propios
        allow read: if isOwner(userId);
        
        // CREATE: Validar campos requeridos y límites
        // Uses getAfter to validate user doc is being updated in same transaction
        allow create: if isOwner(userId)
          && request.resource.data.levelId == levelId
          && request.resource.data.completed == true
          && request.resource.data.attempts >= 1 && request.resource.data.attempts <= 1000
          && request.resource.data.usedHints >= 0
          && request.resource.data.xpEarned >= 0 && request.resource.data.xpEarned <= 300
          && request.resource.data.stars >= 1 && request.resource.data.stars <= 3
          && request.resource.data.blockCount >= 1 && request.resource.data.blockCount <= 100
          && request.resource.data.worldId is string
          // Atomicity validation: user doc must be updated in same transaction
          && (
            getAfter(/databases/$(database)/documents/users/$(userId)).data.totalXP 
            >= get(/databases/$(database)/documents/users/$(userId)).data.totalXP
          );
        
        // INMUTABLE: No updates ni deletes
        allow update, delete: if false;
      }
    }
    
    // ============================================
    // LEGACY PROGRESS COLLECTION (for migration)
    // Read-only for backwards compatibility
    // ============================================
    
    match /progress/{progressId} {
      // READ: Solo registros propios
      allow read: if isAuthenticated() 
        && resource.data.userId == request.auth.uid;
      
      // No new writes allowed - use subcollection instead
      allow create, update, delete: if false;
    }
    
    // ============================================
    // LEVELS COLLECTION
    // Solo lectura para usuarios autenticados
    // ============================================
    
    match /levels/{levelId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // WORLDS COLLECTION
    // Solo lectura para jugadores
    // ============================================
    
    match /worlds/{worldId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // MAP FRAGMENTS COLLECTION
    // Solo lectura
    // ============================================
    
    match /mapFragments/{fragmentId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // BADGES COLLECTION (catálogo)
    // Solo lectura
    // ============================================
    
    match /badges/{badgeId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // ============================================
    // LEADERBOARD COLLECTION
    // Lectura pública, escritura solo server/admin
    // ============================================
    
    match /leaderboard/{entry} {
      allow read: if true;
      allow write: if false;
    }
  }
}
